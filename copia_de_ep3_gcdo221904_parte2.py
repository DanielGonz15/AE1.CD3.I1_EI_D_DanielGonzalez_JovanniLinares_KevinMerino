# -*- coding: utf-8 -*-
"""Copia de EP3_GCDO221904_Parte2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W7r7Yh08YDZt6fTS9Yb2J9-RMFRGKJLj
"""

#Práctina 7: Entrenamiento y evaluación de una CNN
#Importar las librerías requeridas
#hola

from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten, Activation
from tensorflow.keras.preprocessing.image import ImageDataGenerator        #Para generar datos sintéticos
from keras import optimizers #Para uzar los optimizadores (cálculo de gradiente decendiente)
from keras.layers import Convolution2D, MaxPooling2D

#Definir la ruta de las imágenes
entrenamiento = "/content/drive/MyDrive/billetes/entrenar"
validacion = "/content/drive/MyDrive/billetes/validar"
#Definir  los hiperparametros de la arquitectura CNN
epocas = 20
altura, longitud = 150, 150
batch_size = 2
pasos = 100

#Definir los hiperparametros de las capas convolucionales
kernel1=32
kernel2=64
kernel1_size=(3,3)
kernel2_size=(3,3)
size_pooling=(3,3)

clases=10
lr=0.0004

#Generar datos sintéticos (ayuda cuando tenemos pocos datos de entrenamiento)

entrenar = ImageDataGenerator(
    rescale=1/200,
    zoom_range=0.3,
    horizontal_flip=True
)
validar = ImageDataGenerator(
    rescale=1/200
)

#Leemos las imágenes
imagenes_entrenamiento = entrenar.flow_from_directory(
    entrenamiento,
    target_size=(altura, longitud),
    batch_size=batch_size,
    class_mode='categorical'
    )
imagenes_validacion = validar.flow_from_directory(
    validacion,
    target_size=(altura, longitud),
    batch_size=batch_size,
    class_mode='categorical'
    )

#Construir la arquitectura de la CNN

modeloCNN=Sequential()
#Capa convolucional
#Primera Capa
modeloCNN.add(Convolution2D(kernel1, kernel1_size, padding="same", input_shape=(altura, longitud, 3),activation="relu"))
modeloCNN.add(Activation("relu"))
#Agregar un submuestreo
modeloCNN.add(MaxPooling2D(pool_size=size_pooling))
#Segunda capa
modeloCNN.add(Convolution2D(kernel2, kernel2_size, padding="same", input_shape=(altura, longitud, 3),activation="relu"))
#Agregar un submuestreo
modeloCNN.add(MaxPooling2D(pool_size=size_pooling))
modeloCNN.add(Flatten()) #aplana las matrices
#Conectar la MLP
modeloCNN.add(Dense(100, activation="relu"))
modeloCNN.add(Dense(200, activation="relu"))
modeloCNN.add(Dropout(0.3))
#Capa de salida
modeloCNN.add(Dense(clases, activation="softmax"))

#Establecer los parametros de entrenamiento
modeloCNN.compile(loss="categorical_crossentropy", optimizer="adam", metrics=["acc","mse"])

#Entrenar modelo CNN
modeloCNN.fit(imagenes_entrenamiento,
              validation_data=imagenes_validacion,
              epochs=epocas,validation_steps=pasos,verbose=1)

#Guardar el modelo entrenado
#Guarda la arquitectura
modeloCNN.save("/content/drive/MyDrive/billetes/modelo/modeloCNN8D.h5")
#Guarda los pesos
modeloCNN.save_weights("/content/drive/MyDrive/billetes/modelo/pesos.weights.h5")

#Proceso de evaluación o reconocimiento de los patrones
import numpy as np
from tensorflow.keras.utils import load_img, img_to_array
from keras.models import load_model
import os.path

#Imagen a clasificar
imagen = "/content/drive/MyDrive/billetes/entrenar/CruzBilletes500/cruzBillete5008.jpg"
altura, longitud = 150, 150
#cargar el modelo: arquitectura y pesos
modelo = "/content/drive/MyDrive/billetes/modelo/modeloCNN8D.h5"
pesos = "/content/drive/MyDrive/billetes/modelo/pesos.weights.h5"
modeloCNN = load_model(modelo)
modeloCNN.load_weights(pesos)
#Transformar la imagen a clasificar
imagen = load_img(imagen, target_size=(altura, longitud))
imagen = img_to_array(imagen)
imagen = np.expand_dims(imagen, axis=0)
#Predecir
resultado = modeloCNN.predict(imagen)
print(resultado)
max = np.argmax(resultado)
if max == 0:
  print("Cara billete de 20")
elif max ==1:
  print("Cara billete de 100")
elif max ==2:
  print("Cruz billete de 200")
elif max ==3:
  print("Cara billete de 50")
elif max ==4:
  print("Cara billete de 500")
elif max ==5:
  print("Cruz billete de 20")
elif max ==6:
  print("Cruz billete de 100")
elif max ==7:
  print("Cruz billete de 200")
elif max ==8:
  print("Cruz billete de 50")
elif max ==9:
  print("Cruz billete de 500")
else:
  print("No se reconoce la fruta")

import cv2
import numpy as np
from tensorflow.keras.models import load_model

# Cargar el modelo .h5
model = load_model('/content/drive/MyDrive/billetes/modelo/modeloCNN8D.h5')

# Las clases de salida (ajústalo según tu entrenamiento)
clases = ['Cara billete 200', 'Cara billete de 500', 'Cruz billete de 200', 'Cruz billete de 5000']

# Función para preprocesar el frame antes de predecir
def preprocess(imagen):
    imagen = cv2.resize(imagen, (224, 224))  # Ajusta al tamaño que usaste en el entrenamiento
    imagen = imagen.astype('float32') / 255.0
    return np.expand_dims(imagen, axis=0)

# Abrir la cámara
cap = cv2.VideoCapture(0)

while True:
    ret, frame = cap.read()
    if not ret:
        break

    # Preprocesar frame
    entrada = preprocess(frame)

    # Hacer predicción
    pred = model.predict(entrada)
    clase = clases[np.argmax(pred)]
    confianza = np.max(pred)

    # Dibujar el nombre y recuadro
    if confianza > 0.8:  # Puedes ajustar este umbral
        cv2.putText(frame, f'{clase} ({confianza:.2f})', (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
        cv2.rectangle(frame, (50, 50), (frame.shape[1]-50, frame.shape[0]-50), (0, 255, 0), 2)

    # Mostrar frame
    cv2.imshow('Detector de Billetes', frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()